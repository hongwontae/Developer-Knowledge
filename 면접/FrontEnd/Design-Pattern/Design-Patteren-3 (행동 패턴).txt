1. 행동 패턴
=> 객체 간의 상호작용을 효율적으로 관리하는 패턴입니다.


2. 옵저버 패턴
=> 한 객체에 상태 변화가 있을 떄, 이를 감지하고 여러 객체에게 자동으로 알리는 패턴입니다.
=> 발행 - 구독 개념을 기반으로 이벤트 리스너처럼 동작하는 패턴입니다.

2-1. 옵저버 패턴이 필요한 이유
1. 객체 간의 의존성을 줄일 수 있음 (느슨한 결합, Loose Coupling)
=> Subject(발행자)와 Observer(구독자)가 직접적으로 연결되지 않고, 독립적으로 동작할 수 있습니다.

2. 이벤트 기반 시스템 구현 가능합니다.
=> UI 이벤트 리스너, 실시간 데이터 업데이트 등에 활용됩니다.

3. 상태 변경을 효율적으로 관리합니다.
=> 한 객체의 변경 사항이 여러 객체에 자동으로 반영됩니다.


2-2. 옵저버 패턴의 기본 구조
1. 발행자(Subject)
=> 상태를 관리하며, 옵저버를 등록하거나 해제할 수 있습니다.
=> 상태가 변경되면 등록된 모든 옵저버에게 알림을 보냅니다.

2. 구독자 (observer)
=> Subject의 상태 변화를 감지하고 이에 따라 동작을 수행합니다.
=> Subject에 등록되어 있다가 상태 변화가 발생하면 자동으로 업데이트가 됩니다.

** 상태 변화가 발생할 떄 이를 여러 객체에게 자동으로 전달해야 하는가를 기준으로 Observer를 사용합니다. **


3. 상태 패턴
=> 객체의 상태에 따라 행동이 달라지는 경우, 상태를 객체로 분리하여 관리하는 패턴입니다.
=> 조건문을 없애고 각 상태를 별도의 클래스로 분리하는 패턴입니다.

3-1. 상태 패턴이 필요한 이유
1. 조건문을 제거할 수 있습니다.
2. 상태 변경을 유연하게 할 수 있습니다.
3. 객체가 여러 상태를 가질 떄, 코드 유지보수가 쉬워집니다.

3-2. 상태 패턴 구성 요소
1. Context
=> 현재 상태를 관리하며, 상태 변경을 처리하는 역할입니다.
=> Clinet는 Context 객체만 사용하고 상태를 직접 관리하지 않습니다.

2. State
=> 여러 상태를 클래스로 분리하여 구현합니다.
=> handle() 메서드를 통해 행동을 정의합니다.

3. Concrete State (구체적인 상태)
=> 실제로 동작하는 상태 클래스입니다.
=> 특정 상태에 대한 로직을 정의하고, 필요할 때 Context의 상태를 변경할 수 있습니다.

** 객체의 상태가 바뀔 떄 행동도 함께 변경해야 하는가를 기준으로 상태 패턴을 사용하면 됩니다. ***




