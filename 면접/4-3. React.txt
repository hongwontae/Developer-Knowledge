1. ⭐ 라이프사이클에 대해 설명해주세요.
=> 컴포넌트는 생성부터 종료가지 라이플사이클을 거칩니다.
=> 마운트, 업데이트, 언마운트 단계가 존재하고 이 단계에서 특정 작업을 할 수 있는 메서드들이 존재합니다.


2. ⭐ 라이프 사이클 메소드에 대해 설명해주세요.
=> componentDidMount: 컴포넌트가 마운트된 후 호출됩니다. 주로 데이터 로딩 등 비동기 작업에 사용.
=> shouldComponentUpdate: 컴포넌트가 업데이트될지 여부를 결정합니다. 성능 최적화에 사용.
=> componentDidUpdate: 컴포넌트가 업데이트된 후 호출됩니다.
=> componentWillUnmount: 컴포넌트가 언마운트되기 전에 호출됩니다. 리소스 정리에 사용됩니다.


3. 함수형 컴포넌트의 장점에 대해 설명해주세요.
=> 간결한 코드, React Hooks를 사용해서 상태관리와 라이프사이클을(useEffect) 효율적으로 다룰 수 있습니다.
=> 라이프사이클 메서드가 없어서 필요한 시점에만 리렌더링을 유도할 수 있습니다.
(shouldComponentUpdate가 기본적으로 없으면 상태 변화가 없어도 렌더링이 발생할 수 있습니다.)


4. ⭐ 함수형 컴포넌트에서 클래스형 컴포넌트의 라이프 사이클 메소드를 비슷하게 사용하는 방법에 대해 설명해주세요. (useEffect => ComponentDidMount, ComponentDidUpdate, ComponentWillUnmount)
=> useEffect을 사용해서 클래스형 컴포넌트의 라이프 사이클 메서드를 대체할 수 있습니다.
=> componentDidMount는 useEffect(()=>{}, [])
=> componentDidUpdate는 useEffect(()=>{}, [])
=> componentWillUnmount는 useEffect(()=>{return ()=>{}}, [])


5. React 에서 상태 변화가 생겼을 때, 변화를 어떻게 알아채는지에 대해 설명해주세요.
=> useState의 setState가 호출되면 React가 컴포넌트 상태가 변경되었다는 것을 인식합니다.
=> 새로운 변경사항이 들어간 가상 DOM을 생성하고 기존의 가상 DOM과 비교합니다.
=> 변경사항만 실제 DOM에 추가합니다.


6. React에서 State의 불변성은 어떻게 유지할 수 있나요?
=> 상태의 복사본을 사용하여 변경한 후 새로운 객체를 setState에 설정해야 합니다.
=> spread 연산자나 object.assign을 사용합니다. immer 라이브러리의 도움을 받을 수 도 있습니다. (deep copy)


7. setState는 동기적으로 동작하나요? 아니면 비동기적으로 동작하나요?
=> 비동기적으로 동작합니다.


8. 왜 비동기적으로 동작하나요?
=> 배치 처리를 위해서 비동기적으로 동작합니다.


9. ⭐ Key Props를 사용하는 이유에 대해 설명해주세요.
=> key는 리액트가 각 요소를 고유하게 식별할 수 있도록 해줍니다.
=> 동적인 요소가 존재할 떄 key가 없거나 인덱스로 key를 대체하면 식별자가 고유하지 못해 불필요한
리렌더링이 발생합니다.


10. 제어 컴포넌트와 비제어 컴포넌트의 차이에 대해 설명해주세요.
=> 제어 컴포넌트는 state를 통해 관리하고 비제어 컴포넌트는 ref를 사용하여 DOM 자체에서 상태를 관리합니다.

